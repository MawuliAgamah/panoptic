<!-- Data Loader Component - Handles loading and processing knowledge graph data -->
<div class="data-loader-component" id="data-loader">
    <div class="loader-status">
        <div class="status-indicator" id="status-indicator">
            <span class="status-icon">‚ö™</span>
            <span class="status-text">Ready to load data</span>
        </div>
        <div class="loader-actions">
            <button id="manual-load-btn" class="load-btn">
                üîÑ Reload Data
            </button>
            <button id="auto-refresh-toggle" class="toggle-btn" data-enabled="false">
                üîÅ Auto-refresh: OFF
            </button>
        </div>
    </div>

    <div class="data-info" id="data-info" style="display: none;">
        <div class="info-grid">
            <div class="info-item">
                <span class="info-label">Last Updated:</span>
                <span class="info-value" id="last-updated">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">Data Source:</span>
                <span class="info-value" id="data-source">knowledge_store.json</span>
            </div>
            <div class="info-item">
                <span class="info-label">Load Time:</span>
                <span class="info-value" id="load-time">-</span>
            </div>
        </div>
    </div>
</div>

<style>
    .data-loader-component {
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }

    .loader-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .status-icon {
        font-size: 12px;
    }

    .status-text {
        font-size: 14px;
        color: #2c3e50;
        font-weight: 500;
    }

    .loader-actions {
        display: flex;
        gap: 10px;
    }

    .load-btn,
    .toggle-btn {
        padding: 6px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.3s ease;
    }

    .load-btn {
        background: #3498db;
        color: white;
    }

    .load-btn:hover {
        background: #2980b9;
    }

    .load-btn:disabled {
        background: #bdc3c7;
        cursor: not-allowed;
    }

    .toggle-btn {
        background: #ecf0f1;
        color: #2c3e50;
    }

    .toggle-btn:hover {
        background: #d5dbdb;
    }

    .toggle-btn[data-enabled="true"] {
        background: #27ae60;
        color: white;
    }

    .data-info {
        border-top: 1px solid #eee;
        padding-top: 10px;
    }

    .info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
    }

    .info-item {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .info-label {
        font-size: 11px;
        color: #7f8c8d;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .info-value {
        font-size: 12px;
        color: #2c3e50;
        font-weight: 500;
    }

    /* Status States */
    .status-loading .status-icon {
        animation: spin 1s linear infinite;
    }

    .status-success .status-icon {
        color: #27ae60;
    }

    .status-error .status-icon {
        color: #e74c3c;
    }

    .status-idle .status-icon {
        color: #95a5a6;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    /* Loading animation */
    .loading-pulse {
        animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
        0% {
            opacity: 1;
        }

        50% {
            opacity: 0.6;
        }

        100% {
            opacity: 1;
        }
    }
</style>

<script>
    // Data Loader Component Logic
    (function () {
        const dataLoader = {
            data: null,
            autoRefreshInterval: null,
            autoRefreshEnabled: false,
            refreshIntervalMs: 30000, // 30 seconds

            init: function () {
                this.bindEvents();
                console.log('üì° Data loader component initialized');

                // Auto-load data on initialization
                setTimeout(() => {
                    console.log('üöÄ Auto-loading data on component initialization...');
                    this.loadData();
                }, 100);
            },

            bindEvents: function () {
                // Manual load button
                const loadBtn = document.getElementById('manual-load-btn');
                if (loadBtn) {
                    loadBtn.addEventListener('click', () => this.loadData());
                }

                // Auto-refresh toggle
                const toggleBtn = document.getElementById('auto-refresh-toggle');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => this.toggleAutoRefresh());
                }

                // Listen for document uploads to refresh data
                document.addEventListener('graph:documentUploaded', () => {
                    setTimeout(() => this.loadData(), 1000); // Give server time to process
                });
            },

            async loadData() {
                const startTime = performance.now();
                this.setStatus('loading', 'Loading knowledge graph data...');
                this.setLoadButtonState(false);

                try {
                    console.log('üì° Fetching knowledge graph data...');

                    const response = await fetch('/database/knowledge_store.json', {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const loadTime = Math.round(performance.now() - startTime);

                    // Process and validate data
                    const processedData = this.processData(data);

                    if (processedData) {
                        this.data = processedData;
                        this.setStatus('success', `Loaded ${processedData.entities.length} entities, ${processedData.relationships.length} relationships`);
                        this.updateDataInfo(loadTime);
                        this.showDataInfo();

                        // Emit event for other components
                        this.emit('dataLoaded', processedData);

                        console.log('‚úÖ Data loaded successfully:', processedData);
                    } else {
                        throw new Error('Invalid data format');
                    }

                } catch (error) {
                    console.error('‚ùå Error loading data:', error);
                    console.log('üîç Debug info - checking /api/debug/data endpoint...');

                    // Try to get debug info
                    try {
                        const debugResponse = await fetch('/api/debug/data');
                        if (debugResponse.ok) {
                            const debugData = await debugResponse.json();
                            console.log('üîç Debug data:', debugData);
                        }
                    } catch (debugError) {
                        console.log('üîç Could not fetch debug data:', debugError);
                    }

                    this.setStatus('error', `Failed to load data: ${error.message}`);
                    this.emit('dataError', { error: error.message });
                }

                this.setLoadButtonState(true);
            },

            processData: function (rawData) {
                if (!rawData || typeof rawData !== 'object') {
                    console.warn('Invalid data format');
                    return null;
                }

                // Ensure required structure
                const processedData = {
                    entities: rawData.entities || [],
                    relationships: rawData.relationships || [],
                    metadata: rawData.metadata || {}
                };

                // Process entities - ensure they have required properties
                processedData.entities = processedData.entities.map(entity => ({
                    id: entity.id,
                    name: entity.name || `Entity ${entity.id}`,
                    type: entity.type || 'unknown',
                    domain: entity.domain || 'general',
                    document_ids: entity.document_ids || [],
                    metadata: entity.metadata || {},
                    ...entity
                }));

                // Process relationships - filter out invalid ones
                processedData.relationships = processedData.relationships.filter(rel =>
                    (rel.source_id && rel.target_id) || (rel.source_entity && rel.target_entity)
                );

                console.log(`üìä Processed ${processedData.relationships.length} relationships out of ${rawData.relationships?.length || 0} total`);

                // Extract documents for filtering
                const documentMap = new Map();
                processedData.entities.forEach(entity => {
                    if (entity.document_ids) {
                        entity.document_ids.forEach(docId => {
                            if (!documentMap.has(docId)) {
                                documentMap.set(docId, {
                                    id: docId,
                                    title: entity.metadata?.title || docId,
                                    count: 1
                                });
                            } else {
                                documentMap.get(docId).count++;
                            }
                        });
                    }
                });

                processedData.documents = Array.from(documentMap.values());

                // Update metadata
                processedData.metadata = {
                    ...processedData.metadata,
                    total_entities: processedData.entities.length,
                    total_relationships: processedData.relationships.length,
                    unique_documents: processedData.documents.length,
                    processed_at: new Date().toISOString()
                };

                console.log(`üìä Processed ${processedData.entities.length} entities and ${processedData.relationships.length} relationships`);
                return processedData;
            },

            setStatus: function (type, message) {
                const indicator = document.getElementById('status-indicator');
                const statusIcon = indicator.querySelector('.status-icon');
                const statusText = indicator.querySelector('.status-text');

                // Remove existing status classes
                indicator.className = 'status-indicator';

                switch (type) {
                    case 'loading':
                        indicator.classList.add('status-loading');
                        statusIcon.textContent = '‚ü≥';
                        break;
                    case 'success':
                        indicator.classList.add('status-success');
                        statusIcon.textContent = '‚úÖ';
                        break;
                    case 'error':
                        indicator.classList.add('status-error');
                        statusIcon.textContent = '‚ùå';
                        break;
                    default:
                        indicator.classList.add('status-idle');
                        statusIcon.textContent = '‚ö™';
                }

                statusText.textContent = message;
            },

            setLoadButtonState: function (enabled) {
                const loadBtn = document.getElementById('manual-load-btn');
                if (loadBtn) {
                    loadBtn.disabled = !enabled;
                    if (enabled) {
                        loadBtn.classList.remove('loading-pulse');
                    } else {
                        loadBtn.classList.add('loading-pulse');
                    }
                }
            },

            updateDataInfo: function (loadTime) {
                const lastUpdated = document.getElementById('last-updated');
                const loadTimeEl = document.getElementById('load-time');

                if (lastUpdated) {
                    lastUpdated.textContent = new Date().toLocaleTimeString();
                }

                if (loadTimeEl) {
                    loadTimeEl.textContent = `${loadTime}ms`;
                }
            },

            showDataInfo: function () {
                const dataInfo = document.getElementById('data-info');
                if (dataInfo) {
                    dataInfo.style.display = 'block';
                }
            },

            toggleAutoRefresh: function () {
                this.autoRefreshEnabled = !this.autoRefreshEnabled;
                const toggleBtn = document.getElementById('auto-refresh-toggle');

                if (this.autoRefreshEnabled) {
                    this.startAutoRefresh();
                    toggleBtn.textContent = 'üîÅ Auto-refresh: ON';
                    toggleBtn.setAttribute('data-enabled', 'true');
                } else {
                    this.stopAutoRefresh();
                    toggleBtn.textContent = 'üîÅ Auto-refresh: OFF';
                    toggleBtn.setAttribute('data-enabled', 'false');
                }

                console.log('üîÑ Auto-refresh:', this.autoRefreshEnabled ? 'enabled' : 'disabled');
            },

            startAutoRefresh: function () {
                this.stopAutoRefresh(); // Clear any existing interval

                this.autoRefreshInterval = setInterval(() => {
                    console.log('üîÑ Auto-refreshing data...');
                    this.loadData();
                }, this.refreshIntervalMs);
            },

            stopAutoRefresh: function () {
                if (this.autoRefreshInterval) {
                    clearInterval(this.autoRefreshInterval);
                    this.autoRefreshInterval = null;
                }
            },

            // Public methods
            getData: function () {
                return this.data;
            },

            isDataLoaded: function () {
                return this.data !== null;
            },

            refreshData: function () {
                return this.loadData();
            },

            // Event emission
            emit: function (eventName, data) {
                const event = new CustomEvent('graph:' + eventName, { detail: data });
                document.dispatchEvent(event);
                console.log('üì° DataLoader emitted:', 'graph:' + eventName, data);
            }
        };

        // Auto-initialize when component is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => dataLoader.init());
        } else {
            dataLoader.init();
        }

        // Make globally available
        window.DataLoader = dataLoader;
    })();
</script>